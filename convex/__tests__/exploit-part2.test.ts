/**
 * EXPLOIT DETECTION TEST SUITE - PART 2
 * 
 * Continuation of exploit detection tests covering:
 * - Loan exploits
 * - Company/Product exploits
 * - Marketplace exploits
 * - Transaction exploits
 */

import { describe, test, expect } from "vitest";
import { convexTest } from "convex-test";
import { api } from "../_generated/api";
import schema from "../schema";

// ============================================================================
// SECTION 4: LOAN EXPLOITS
// ============================================================================

describe("Loan Exploits", () => {
  
  test("EXPLOIT: Creating multiple loans to bypass limits", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-loan-exploiter",
        }),
        balance: 1000000,
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Create max loan
    await t.mutation(api.loans.createLoan, {
      playerId,
      amount: 500000000, // Max $5M
    });
    
    // Try to create another max loan
    try {
      await t.mutation(api.loans.createLoan, {
        playerId,
        amount: 500000000,
      });
      
      // Check total debt
      const totalDebt = await t.query(api.loans.getPlayerTotalDebt, {
        playerId,
      });
      
      if (totalDebt > 500000000) {
        console.warn(`⚠️  EXPLOIT DETECTED: Total debt ${totalDebt} exceeds max loan amount`);
      }
    } catch (error) {
      // May be blocked, which is good
    }
  });
  
  test("EXPLOIT: Loan repayment with negative amount", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-loan-repay",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const loanId = await t.mutation(api.loans.createLoan, {
      playerId,
      amount: 1000000,
    });
    
    // Try negative repayment (would add money)
    try {
      await t.mutation(api.loans.repayLoan, {
        loanId,
        amount: -500000,
      });
      
      const loan = await t.query(api.loans.getLoan, {
        loanId,
      });
      
      if (loan && loan.remainingBalance > 1000000) {
        console.error("⚠️  EXPLOIT DETECTED: Negative repayment increased loan balance");
        expect.fail("Negative repayment exploit");
      }
    } catch (error) {
      // Expected to fail
    }
  });
  
  test("EXPLOIT: Interest calculation overflow", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-interest",
        }),
        balance: 1000000,
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Create loan with very old timestamp
    const loanId = await t.run(async (ctx) => {
      const veryOldTime = Date.now() - (365 * 10 * 24 * 60 * 60 * 1000); // 10 years ago
      return await ctx.db.insert("loans", {
        playerId,
        amount: 100000000,
        interestRate: 5,
        remainingBalance: 100000000,
        accruedInterest: 0,
        createdAt: veryOldTime,
        lastInterestApplied: veryOldTime,
        status: "active",
      });
    });
    
    // Apply interest
    try {
      await t.mutation(api.loans.applyLoanInterest);
      
      const loan = await t.query(api.loans.getLoan, {
        loanId,
      });
      
      if (loan && !Number.isFinite(loan.remainingBalance)) {
        console.error("⚠️  EXPLOIT DETECTED: Interest calculation resulted in invalid number");
        expect.fail("Interest overflow");
      }
      
      if (loan && loan.remainingBalance > Number.MAX_SAFE_INTEGER / 2) {
        console.warn("⚠️  WARNING: Interest calculation approaching unsafe values");
      }
    } catch (error) {
      // May fail, which is acceptable
    }
  });
  
  test("EXPLOIT: Repaying loan after marking as paid", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-double-repay",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const loanId = await t.mutation(api.loans.createLoan, {
      playerId,
      amount: 1000000,
    });
    
    // Repay full loan
    await t.mutation(api.loans.repayLoan, {
      loanId,
      amount: 1000000,
    });
    
    // Try to repay again
    try {
      await t.mutation(api.loans.repayLoan, {
        loanId,
        amount: 100000,
      });
      
      // Check if balance was incorrectly credited
      const player = await t.run(async (ctx) => {
        return await ctx.db.get(playerId);
      });
      
      if (player && player.balance > 10000000) {
        console.error("⚠️  EXPLOIT DETECTED: Double loan repayment credited balance");
        expect.fail("Double repayment exploit");
      }
    } catch (error: any) {
      expect(error.message).toContain("not active");
    }
  });
  
  test("EXPLOIT: Loan interest compounding too frequently", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-compound",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    await t.mutation(api.loans.createLoan, {
      playerId,
      amount: 1000000,
    });
    
    const initialBalance = 1000000;
    
    // Apply interest multiple times in quick succession
    for (let i = 0; i < 5; i++) {
      try {
        await t.mutation(api.loans.applyLoanInterest);
      } catch (error) {
        // May fail
      }
    }
    
    const totalDebt = await t.query(api.loans.getPlayerTotalDebt, {
      playerId,
    });
    
    // Interest should only apply once per day, not multiple times
    const maxExpectedDebt = initialBalance * 1.05; // 5% for one day
    
    if (totalDebt > maxExpectedDebt * 1.1) {
      console.warn(`⚠️  EXPLOIT DETECTED: Interest applied multiple times. Debt: ${totalDebt}, Expected: ~${maxExpectedDebt}`);
    }
  });
});

// ============================================================================
// SECTION 5: COMPANY & PRODUCT EXPLOITS
// ============================================================================

describe("Company & Product Exploits", () => {
  
  test("EXPLOIT: Going public with insufficient balance", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-ipo",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Poor IPO Co",
        balance: 1000000, // Only $10k, need $50k
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    try {
      await t.mutation(api.companies.makeCompanyPublic, {
        companyId,
        ticker: "POOR",
        totalShares: 10000,
      });
      expect.fail("Should not allow IPO with insufficient balance");
    } catch (error: any) {
      expect(error.message).toContain("50,000");
    }
  });
  
  test("EXPLOIT: Creating product with negative production cost", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-product-creator",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Product Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Create product with very low price
    const productId = await t.mutation(api.products.createProduct, {
      companyId,
      name: "Test Product",
      price: 100,
    });
    
    // Check that production cost percentage is reasonable
    const product = await t.run(async (ctx) => {
      return await ctx.db.get(productId);
    });
    
    if (product && product.productionCostPercentage < 0) {
      console.error("⚠️  EXPLOIT DETECTED: Negative production cost percentage");
      expect.fail("Negative production cost percentage exploit");
    }
    
    if (product && product.productionCostPercentage >= 1) {
      console.warn("⚠️  WARNING: Production cost percentage >= 100% (no profit margin)");
    }
  });
  
  test("EXPLOIT: Ordering products with insufficient company balance", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-order",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Poor Company",
        balance: 1000, // Very low
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.mutation(api.products.createProduct, {
      companyId,
      name: "Expensive Product",
      price: 10000,
    });
    
    try {
      await t.mutation(api.products.orderProductBatch, {
        productId,
        quantity: 1000, // Would cost way more than company has
      });
      expect.fail("Should not allow ordering with insufficient balance");
    } catch (error: any) {
      expect(error.message).toContain("Insufficient balance");
    }
  });
  
  test("EXPLOIT: Product stock manipulation", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-stock-manip",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Stock Manip Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.run(async (ctx) => {
      return await ctx.db.insert("products", {
        companyId,
        name: "Limited Stock",
        price: 1000,
        productionCostPercentage: 0.5, // 50%
        stock: 100,
        totalRevenue: 0,
        totalSold: 0,
        qualityRating: 0.5,
        isActive: true,
        isArchived: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to update stock directly without paying
    try {
      await t.mutation(api.products.updateProductStock, {
        productId,
        quantityChange: 10000, // Add massive stock
      });
      
      const product = await t.run(async (ctx) => {
        return await ctx.db.get(productId);
      });
      
      // Check if company paid for the stock
      const company = await t.run(async (ctx) => {
        return await ctx.db.get(companyId);
      });
      
      if (product && product.stock !== undefined && product.stock > 100 && company && company.balance === 10000000) {
        console.error("⚠️  EXPLOIT DETECTED: Stock added without payment");
        expect.fail("Free stock exploit");
      }
    } catch (error) {
      // May not have this mutation exposed
    }
  });
  
  test("EXPLOIT: Duplicate company ticker symbols", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-ticker",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Create first company and make public
    const company1Id = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "First Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    await t.mutation(api.companies.makeCompanyPublic, {
      companyId: company1Id,
      ticker: "DUPE",
      totalShares: 10000,
    });
    
    // Try to create second company with same ticker
    const company2Id = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Second Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    try {
      await t.mutation(api.companies.makeCompanyPublic, {
        companyId: company2Id,
        ticker: "DUPE",
        totalShares: 10000,
      });
      expect.fail("Should not allow duplicate ticker");
    } catch (error: any) {
      expect(error.message).toContain("already in use");
    }
  });
  
  test("EXPLOIT: IPO with zero or negative shares", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-ipo-shares",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Zero Shares Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    try {
      await t.mutation(api.companies.makeCompanyPublic, {
        companyId,
        ticker: "ZERO",
        totalShares: 0,
      });
      expect.fail("Should not allow IPO with zero shares");
    } catch (error: any) {
      expect(error.message).toContain("positive");
    }
    
    try {
      await t.mutation(api.companies.makeCompanyPublic, {
        companyId,
        ticker: "NEG",
        totalShares: -1000,
      });
      expect.fail("Should not allow IPO with negative shares");
    } catch (error: any) {
      expect(error.message).toContain("positive");
    }
  });
});

// ============================================================================
// SECTION 6: MARKETPLACE & CART EXPLOITS
// ============================================================================

describe("Marketplace & Cart Exploits", () => {
  
  test("EXPLOIT: Adding products exceeding max per order", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-cart-user",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Limited Order Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.run(async (ctx) => {
      return await ctx.db.insert("products", {
        companyId,
        name: "Limited Product",
        price: 1000,
        productionCostPercentage: 0.5, // 50%
        stock: 1000,
        maxPerOrder: 10, // Max 10 per order
        totalRevenue: 0,
        totalSold: 0,
        qualityRating: 0.5,
        isActive: true,
        isArchived: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    try {
      await t.mutation(api.cart.addToCart, {
        userId: playerId,
        productId,
        quantity: 100, // Exceeds max
      });
      expect.fail("Should not allow adding more than max per order");
    } catch (error: any) {
      expect(error.message).toContain("Maximum");
    }
  });
  
  test("EXPLOIT: Buying products with insufficient stock", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-stock-buyer",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Low Stock Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.run(async (ctx) => {
      return await ctx.db.insert("products", {
        companyId,
        name: "Scarce Product",
        price: 1000,
        productionCostPercentage: 0.5, // 50%
        stock: 5, // Only 5 in stock
        totalRevenue: 0,
        totalSold: 0,
        qualityRating: 0.5,
        isActive: true,
        isArchived: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    try {
      await t.mutation(api.cart.addToCart, {
        userId: playerId,
        productId,
        quantity: 50, // Way more than available
      });
      expect.fail("Should not allow buying more than available stock");
    } catch (error: any) {
      expect(error.message).toContain("stock");
    }
  });
  
  test("EXPLOIT: Price change between cart and checkout", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-price-change",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Price Change Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.run(async (ctx) => {
      return await ctx.db.insert("products", {
        companyId,
        name: "Price Change Product",
        price: 1000,
        productionCostPercentage: 0.5, // 50%
        stock: 100,
        totalRevenue: 0,
        totalSold: 0,
        qualityRating: 0.5,
        isActive: true,
        isArchived: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Add to cart at original price
    await t.mutation(api.cart.addToCart, {
      userId: playerId,
      productId,
      quantity: 5,
    });
    
    // Change product price
    await t.run(async (ctx) => {
      await ctx.db.patch(productId, {
        price: 10000, // 10x price increase
        updatedAt: Date.now(),
      });
    });
    
    // Get cart to check which price is used
    const cart = await t.run(async (ctx) => {
      return await ctx.db
        .query("carts")
        .withIndex("by_userId", (q) => q.eq("userId", playerId))
        .unique();
    });
    
    if (cart) {
      const cartItems = await t.run(async (ctx) => {
        return await ctx.db
          .query("cartItems")
          .withIndex("by_cartId", (q) => q.eq("cartId", cart._id))
          .collect();
      });
      
      const item = cartItems[0];
      if (item && item.pricePerUnit !== 1000) {
        console.warn("⚠️  WARNING: Cart price may not be locked at add time");
      }
    }
  });
  
  test("EXPLOIT: Adding archived/inactive products to cart", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-archived",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Archived Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.run(async (ctx) => {
      return await ctx.db.insert("products", {
        companyId,
        name: "Archived Product",
        price: 1000,
        productionCostPercentage: 0.5, // 50%
        stock: 100,
        totalRevenue: 0,
        totalSold: 0,
        qualityRating: 0.5,
        isActive: false, // Inactive
        isArchived: true, // Archived
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    try {
      await t.mutation(api.cart.addToCart, {
        userId: playerId,
        productId,
        quantity: 1,
      });
      expect.fail("Should not allow adding archived products to cart");
    } catch (error: any) {
      expect(error.message).toContain("not available");
    }
  });
  
  test("EXPLOIT: Cart total price manipulation", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-cart-total",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Cart Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.run(async (ctx) => {
      return await ctx.db.insert("products", {
        companyId,
        name: "Test Product",
        price: 1000,
        productionCostPercentage: 0.5, // 50%
        stock: 100,
        totalRevenue: 0,
        totalSold: 0,
        qualityRating: 0.5,
        isActive: true,
        isArchived: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    await t.mutation(api.cart.addToCart, {
      userId: playerId,
      productId,
      quantity: 5,
    });
    
    const cart = await t.run(async (ctx) => {
      return await ctx.db
        .query("carts")
        .withIndex("by_userId", (q) => q.eq("userId", playerId))
        .unique();
    });
    
    if (cart) {
      // Verify cart total matches item prices
      const cartItems = await t.run(async (ctx) => {
        return await ctx.db
          .query("cartItems")
          .withIndex("by_cartId", (q) => q.eq("cartId", cart._id))
          .collect();
      });
      
      const calculatedTotal = cartItems.reduce(
        (sum, item) => sum + item.pricePerUnit * item.quantity,
        0
      );
      
      if (Math.abs(cart.totalPrice - calculatedTotal) > 1) {
        console.error("⚠️  EXPLOIT DETECTED: Cart total doesn't match item prices");
        expect.fail("Cart total manipulation detected");
      }
    }
  });
});
