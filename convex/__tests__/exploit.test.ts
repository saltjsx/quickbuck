/**
 * EXPLOIT DETECTION TEST SUITE
 * 
 * This comprehensive test suite detects potential exploits across ALL game mechanics.
 * Tests are organized by system and check for:
 * - Negative value exploits
 * - Overflow/underflow exploits
 * - Race conditions
 * - Duplication exploits
 * - Price manipulation
 * - Balance manipulation
 * - Transaction exploits
 * - State inconsistencies
 * - Timing exploits
 * - Authorization bypasses
 */

import { describe, test, expect, beforeEach } from "vitest";
import { convexTest } from "convex-test";
import { api } from "../_generated/api";
import schema from "../schema";

// ============================================================================
// SECTION 1: BALANCE & CURRENCY EXPLOITS
// ============================================================================

describe("Balance & Currency Exploits", () => {
  
  test("EXPLOIT: Negative balance creation", async () => {
    const t = convexTest(schema);
    
    // Create player
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-user-1",
        }),
        balance: 1000000, // $10,000
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Attempt to create loan larger than max allowed
    try {
      await t.mutation(api.loans.createLoan, {
        playerId,
        amount: 999999999999, // Extremely large amount
      });
      expect.fail("Should not allow loans exceeding max amount");
    } catch (error: any) {
      expect(error.message).toContain("Loan amount must be between");
    }
    
    // Verify balance wasn't manipulated
    const player = await t.run(async (ctx) => {
      return await ctx.db.get(playerId);
    });
    expect(player?.balance).toBe(1000000);
  });
  
  test("EXPLOIT: Integer overflow on balance", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-user-overflow",
        }),
        balance: Number.MAX_SAFE_INTEGER - 1000,
        netWorth: Number.MAX_SAFE_INTEGER - 1000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to add money that would overflow
    const result = await t.run(async (ctx) => {
      const player = await ctx.db.get(playerId);
      if (!player) throw new Error("Player not found");
      
      const newBalance = player.balance + 100000;
      return {
        original: player.balance,
        added: 100000,
        result: newBalance,
        isOverflow: newBalance > Number.MAX_SAFE_INTEGER,
        isSafe: Number.isSafeInteger(newBalance),
      };
    });
    
    // Check if overflow protection exists
    if (!result.isSafe || result.isOverflow) {
      console.warn("⚠️  EXPLOIT DETECTED: Integer overflow possible on balance");
      expect.fail("Balance calculations should prevent integer overflow");
    }
  });
  
  test("EXPLOIT: Negative payment/withdrawal", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-user-negative",
        }),
        balance: 1000000,
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to gamble with negative bet
    try {
      await t.mutation(api.gambling.playSlots, {
        betAmount: -1000, // Negative bet
      });
      expect.fail("Should not allow negative bet amounts");
    } catch (error: any) {
      expect(error.message).toContain("positive");
    }
  });
  
  test("EXPLOIT: Zero-cost transactions", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-user-zero",
        }),
        balance: 1000000,
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to create product with zero price
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Test Company",
        balance: 1000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    try {
      await t.mutation(api.products.createProduct, {
        companyId,
        name: "Free Product",
        price: 0, // Zero price
      });
      expect.fail("Should not allow zero-price products");
    } catch (error: any) {
      expect(error.message).toContain("greater than 0");
    }
  });
  
  test("EXPLOIT: Race condition on balance deduction", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-user-race",
        }),
        balance: 1000, // Only $10
        netWorth: 1000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Test Company",
        balance: 1000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const productId = await t.run(async (ctx) => {
      return await ctx.db.insert("products", {
        companyId,
        name: "Expensive Product",
        price: 600, // $6
        productionCostPercentage: 0.5, // 50%
        stock: 10,
        totalRevenue: 0,
        totalSold: 0,
        qualityRating: 0.5,
        isActive: true,
        isArchived: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to make multiple simultaneous purchases that exceed balance
    const promises = [
      t.mutation(api.cart.addToCart, {
        userId: playerId,
        productId,
        quantity: 1,
      }).catch(() => null),
      t.mutation(api.cart.addToCart, {
        userId: playerId,
        productId,
        quantity: 1,
      }).catch(() => null),
    ];
    
    await Promise.all(promises);
    
    // Check final balance isn't negative
    const finalPlayer = await t.run(async (ctx) => {
      return await ctx.db.get(playerId);
    });
    
    if (finalPlayer && finalPlayer.balance < 0) {
      console.error("⚠️  EXPLOIT DETECTED: Race condition allowed negative balance");
      expect.fail("Race condition protection failed");
    }
  });
});

// ============================================================================
// SECTION 2: STOCK MARKET EXPLOITS
// ============================================================================

describe("Stock Market Exploits", () => {
  
  test("EXPLOIT: Stock price manipulation via rapid trading", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-trader",
        }),
        balance: 100000000, // $1M
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Trade Target Inc",
        ticker: "TTI",
        balance: 10000000, // $100k
        isPublic: true,
        marketCap: 50000000,
        sharesOutstanding: 10000,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const stockId = await t.run(async (ctx) => {
      return await ctx.db.insert("stocks", {
        companyId,
        ticker: "TTI",
        price: 5000, // $50/share
        totalShares: 10000,
        marketCap: 50000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Record initial price
    const initialStock = await t.run(async (ctx) => {
      return await ctx.db.get(stockId);
    });
    const initialPrice = initialStock!.price;
    
    // Perform rapid buy-sell cycle to manipulate price
    for (let i = 0; i < 5; i++) {
      try {
        await t.mutation(api.stocks.buyStock, {
          userId: playerId,
          stockId,
          shares: 100,
          accountType: "player",
          accountId: playerId,
        });
        
        await t.mutation(api.stocks.sellStock, {
          userId: playerId,
          stockId,
          shares: 100,
          accountType: "player",
          accountId: playerId,
        });
      } catch (error) {
        // May fail due to insufficient balance
        break;
      }
    }
    
    const finalStock = await t.run(async (ctx) => {
      return await ctx.db.get(stockId);
    });
    const finalPrice = finalStock!.price;
    
    // Check if price was manipulated unreasonably
    const priceChangePercent = Math.abs((finalPrice - initialPrice) / initialPrice) * 100;
    
    if (priceChangePercent > 200) {
      console.warn(`⚠️  EXPLOIT DETECTED: Price manipulated by ${priceChangePercent.toFixed(2)}% through rapid trading`);
    }
    
    expect(priceChangePercent).toBeLessThan(200); // Price shouldn't swing more than 200%
  });
  
  test("EXPLOIT: Buying more shares than available", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-overbuyer",
        }),
        balance: 999999999999,
        netWorth: 999999999999,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Limited Shares Co",
        ticker: "LSC",
        balance: 10000000,
        isPublic: true,
        marketCap: 50000000,
        sharesOutstanding: 1000, // Only 1000 shares
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const stockId = await t.run(async (ctx) => {
      return await ctx.db.insert("stocks", {
        companyId,
        ticker: "LSC",
        price: 5000,
        totalShares: 1000,
        marketCap: 5000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to buy more than total shares
    try {
      await t.mutation(api.stocks.buyStock, {
        userId: playerId,
        stockId,
        shares: 10000, // 10x available shares
        accountType: "player",
        accountId: playerId,
      });
      
      // Check if system created more shares than should exist
      const holdings = await t.run(async (ctx) => {
        return await ctx.db
          .query("userStockHoldings")
          .withIndex("by_userId", (q) => q.eq("userId", playerId))
          .collect();
      });
      
      const totalHeld = holdings.reduce((sum, h) => sum + h.shares, 0);
      
      if (totalHeld > 1000) {
        console.error("⚠️  EXPLOIT DETECTED: More shares exist than total supply");
        expect.fail("Share creation exploit detected");
      }
    } catch (error) {
      // Expected to fail
    }
  });
  
  test("EXPLOIT: Selling shares not owned", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-shortseller",
        }),
        balance: 1000000,
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Target Co",
        ticker: "TGT",
        balance: 10000000,
        isPublic: true,
        marketCap: 50000000,
        sharesOutstanding: 10000,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const stockId = await t.run(async (ctx) => {
      return await ctx.db.insert("stocks", {
        companyId,
        ticker: "TGT",
        price: 5000,
        totalShares: 10000,
        marketCap: 50000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to sell shares without owning any
    try {
      await t.mutation(api.stocks.sellStock, {
        userId: playerId,
        stockId,
        shares: 100,
        accountType: "player",
        accountId: playerId,
      });
      expect.fail("Should not allow selling shares not owned");
    } catch (error: any) {
      expect(error.message).toContain("Insufficient shares");
    }
  });
  
  test("EXPLOIT: Stock price set to NaN or Infinity", async () => {
    const t = convexTest(schema);
    
    const companyId = await t.run(async (ctx) => {
      const playerId = await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-nan",
        }),
        balance: 1000000,
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
      
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "NaN Test Co",
        ticker: "NAN",
        balance: 10000000,
        isPublic: true,
        marketCap: 50000000,
        sharesOutstanding: 10000,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const stockId = await t.run(async (ctx) => {
      return await ctx.db.insert("stocks", {
        companyId,
        ticker: "NAN",
        price: 5000,
        totalShares: 10000,
        marketCap: 50000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to set price to NaN
    try {
      await t.mutation(api.stocks.updateStockPrice, {
        stockId,
        newPrice: NaN,
      });
      
      const stock = await t.run(async (ctx) => {
        return await ctx.db.get(stockId);
      });
      
      if (!Number.isFinite(stock!.price)) {
        console.error("⚠️  EXPLOIT DETECTED: Stock price set to invalid value");
        expect.fail("Invalid price accepted");
      }
    } catch (error) {
      // Expected to fail
    }
  });
  
  test("EXPLOIT: Company with insufficient funds for stock buyback", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-buyback",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Poor Company",
        ticker: "POOR",
        balance: 1000, // Very low balance
        isPublic: true,
        marketCap: 50000000,
        sharesOutstanding: 10000,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const stockId = await t.run(async (ctx) => {
      return await ctx.db.insert("stocks", {
        companyId,
        ticker: "POOR",
        price: 5000,
        totalShares: 10000,
        marketCap: 50000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Buy shares
    await t.mutation(api.stocks.buyStock, {
      userId: playerId,
      stockId,
      shares: 10,
      accountType: "player",
      accountId: playerId,
    });
    
    // Try to sell when company can't afford buyback
    try {
      await t.mutation(api.stocks.sellStock, {
        userId: playerId,
        stockId,
        shares: 10,
        accountType: "player",
        accountId: playerId,
      });
      expect.fail("Should prevent selling when company has insufficient funds");
    } catch (error: any) {
      expect(error.message).toContain("insufficient balance");
    }
  });
});

// ============================================================================
// SECTION 3: CRYPTOCURRENCY EXPLOITS
// ============================================================================

describe("Cryptocurrency Exploits", () => {
  
  test("EXPLOIT: Creating crypto with duplicate ticker", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-crypto-creator",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Create first crypto
    await t.mutation(api.crypto.createCryptocurrency, {
      name: "TestCoin",
      symbol: "TEST",
      initialSupply: 1000000,
      initialPrice: 10000,
    });
    
    // Try to create duplicate
    try {
      await t.mutation(api.crypto.createCryptocurrency, {
        name: "TestCoin2",
        symbol: "TEST", // Duplicate symbol
        initialSupply: 1000000,
        initialPrice: 10000,
      });
      expect.fail("Should not allow duplicate crypto symbol");
    } catch (error: any) {
      expect(error.message).toContain("already exists");
    }
  });
  
  test("EXPLOIT: Buying more crypto than total supply", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-crypto-buyer",
        }),
        balance: 999999999999,
        netWorth: 999999999999,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const cryptoId = await t.run(async (ctx) => {
      return await ctx.db.insert("cryptocurrencies", {
        name: "LimitedCoin",
        symbol: "LTD",
        currentPrice: 1000,
        marketCap: 1000000000,
        liquidity: 100000,
        totalSupply: 1000000,
        circulatingSupply: 1000000,
        baseVolatility: 0.1,
        trendDrift: 0,
        lastVolatilityUpdate: Date.now(),
        lastPriceChange: 0,
        createdAt: Date.now(),
        lastUpdated: Date.now(),
      });
    });
    
    // Try to buy more than total supply
    try {
      await t.mutation(api.crypto.buyCrypto, {
        cryptoId,
        amount: 2000000, // 2x total supply
      });
      expect.fail("Should not allow buying more than total supply");
    } catch (error: any) {
      expect(error.message).toContain("more than");
    }
  });
  
  test("EXPLOIT: Circulating supply exceeds total supply", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-supply-check",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const cryptoId = await t.run(async (ctx) => {
      return await ctx.db.insert("cryptocurrencies", {
        name: "SupplyTest",
        symbol: "SUPP",
        currentPrice: 1000,
        marketCap: 1000000,
        liquidity: 10000,
        totalSupply: 1000,
        circulatingSupply: 1000,
        baseVolatility: 0.1,
        trendDrift: 0,
        lastVolatilityUpdate: Date.now(),
        lastPriceChange: 0,
        createdAt: Date.now(),
        lastUpdated: Date.now(),
      });
    });
    
    // Buy crypto to near limit
    await t.mutation(api.crypto.buyCrypto, {
      cryptoId,
      amount: 500,
    });
    
    // Try to buy more than remaining
    try {
      await t.mutation(api.crypto.buyCrypto, {
        cryptoId,
        amount: 600, // Would exceed total
      });
      expect.fail("Should prevent buying more than available");
    } catch (error: any) {
      expect(error.message).toContain("Cannot buy more than");
    }
  });
  
  test("EXPLOIT: Selling more crypto than owned", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-crypto-seller",
        }),
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const cryptoId = await t.run(async (ctx) => {
      return await ctx.db.insert("cryptocurrencies", {
        name: "SellTest",
        symbol: "SELL",
        currentPrice: 1000,
        marketCap: 1000000000,
        liquidity: 100000,
        totalSupply: 1000000,
        circulatingSupply: 1000000,
        baseVolatility: 0.1,
        trendDrift: 0,
        lastVolatilityUpdate: Date.now(),
        lastPriceChange: 0,
        createdAt: Date.now(),
        lastUpdated: Date.now(),
      });
    });
    
    // Buy 50 coins
    await t.mutation(api.crypto.buyCrypto, {
      cryptoId,
      amount: 50,
    });
    
    // Try to sell 100 coins
    try {
      await t.mutation(api.crypto.sellCrypto, {
        cryptoId,
        amount: 100,
      });
      expect.fail("Should not allow selling more than owned");
    } catch (error: any) {
      expect(error.message).toContain("Insufficient");
    }
  });
  
  test("EXPLOIT: Crypto price manipulation through supply manipulation", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      return await ctx.db.insert("players", {
        userId: await ctx.db.insert("users", {
          tokenIdentifier: "test-crypto-manipulator",
        }),
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const cryptoId = await t.run(async (ctx) => {
      return await ctx.db.insert("cryptocurrencies", {
        name: "ManipCoin",
        symbol: "MNIP",
        currentPrice: 10000,
        marketCap: 1000000000,
        liquidity: 100000,
        totalSupply: 100000,
        circulatingSupply: 100000,
        baseVolatility: 0.1,
        trendDrift: 0,
        lastVolatilityUpdate: Date.now(),
        lastPriceChange: 0,
        createdAt: Date.now(),
        lastUpdated: Date.now(),
      });
    });
    
    const initialCrypto = await t.run(async (ctx) => {
      return await ctx.db.get(cryptoId);
    });
    const initialPrice = initialCrypto!.currentPrice;
    
    // Rapid buy-sell cycles
    for (let i = 0; i < 3; i++) {
      try {
        await t.mutation(api.crypto.buyCrypto, {
          cryptoId,
          amount: 100,
        });
        
        await t.mutation(api.crypto.sellCrypto, {
          cryptoId,
          amount: 100,
        });
      } catch (error) {
        break;
      }
    }
    
    const finalCrypto = await t.run(async (ctx) => {
      return await ctx.db.get(cryptoId);
    });
    const finalPrice = finalCrypto!.currentPrice;
    
    const priceChange = Math.abs((finalPrice - initialPrice) / initialPrice) * 100;
    
    if (priceChange > 300) {
      console.warn(`⚠️  EXPLOIT DETECTED: Crypto price manipulated by ${priceChange.toFixed(2)}%`);
    }
  });
});
