# Exploit Detection Test Suite

## Overview

This comprehensive test suite is designed to detect and prevent exploits across all game mechanics in the QuickBuck game. The tests are organized into 4 parts covering 66 different exploit scenarios.

## Test Files

### Part 1: `exploit.test.ts`
**Focus**: Core financial systems
- Balance & Currency Exploits (5 tests)
- Stock Market Exploits (6 tests)
- Cryptocurrency Exploits (5 tests)

### Part 2: `exploit-part2.test.ts`
**Focus**: Business operations and commerce
- Loan Exploits (6 tests)
- Company & Product Exploits (6 tests)
- Marketplace & Cart Exploits (5 tests)

### Part 3: `exploit-part3.test.ts`
**Focus**: Game features and timing
- Gambling Exploits (5 tests)
- Upgrade Exploits (4 tests)
- Transaction & Transfer Exploits (5 tests)
- Timing & Tick Exploits (5 tests)

### Part 4: `exploit-part4.test.ts`
**Focus**: Advanced scenarios and edge cases
- Net Worth & Portfolio Exploits (3 tests)
- Leaderboard Manipulation (2 tests)
- IPO & Market Cap Exploits (3 tests)
- Boundary Conditions & Edge Cases (6 tests)

## Key Vulnerabilities Detected

### 1. **Integer Overflow/Underflow**
- Tests for safe integer boundaries
- Validates calculations don't exceed MAX_SAFE_INTEGER
- Checks for wrapped negative values

### 2. **Negative Value Exploits**
- Prevents negative balances
- Blocks negative bets, purchases, transfers
- Validates all monetary amounts are non-negative

### 3. **Race Conditions**
- Tests concurrent balance deductions
- Validates transaction atomicity
- Checks for money duplication through timing

### 4. **Price Manipulation**
- Detects rapid trading exploitation
- Validates price impact limits
- Checks for unrealistic price swings

### 5. **Supply Violations**
- Prevents buying more than available stock/crypto
- Validates circulating supply <= total supply
- Checks for share/token creation exploits

### 6. **Duplication Exploits**
- Tests for duplicate purchases
- Validates unique tickers/identifiers
- Checks for multi-processing vulnerabilities

### 7. **Authorization Bypasses**
- Validates ownership checks
- Tests permission boundaries
- Checks for privilege escalation

### 8. **Transaction Integrity**
- Validates double-spend prevention
- Checks money conservation laws
- Tests rollback scenarios

### 9. **State Corruption**
- Tests for NaN/Infinity values
- Validates database consistency
- Checks for orphaned records

### 10. **Timing Exploits**
- Tests timestamp manipulation
- Validates tick system integrity
- Checks for front-running opportunities

## Running the Tests

### Run All Exploit Tests
```bash
npm test exploit
```

### Run Individual Test Files
```bash
npm test exploit.test.ts
npm test exploit-part2.test.ts
npm test exploit-part3.test.ts
npm test exploit-part4.test.ts
```

### Run Specific Test Suite
```bash
npm test -- -t "Balance & Currency Exploits"
npm test -- -t "Stock Market Exploits"
```

## Understanding Test Results

### ✅ PASS
The exploit was properly prevented. The system has adequate protection.

### ⚠️ WARNING
The test passed but logged a warning. Review the specific warning for potential issues.

### ❌ FAIL
An exploit was detected. This indicates a critical vulnerability that must be fixed.

### Example Output:
```
⚠️  EXPLOIT DETECTED: More shares exist than total supply
✓ Negative bet protection should be in place
⚠️  WARNING: Price manipulated by 215.32% through rapid trading
```

## Critical Exploits to Monitor

### High Priority
1. **Money Creation**: Any test showing money appearing from nothing
2. **Negative Balances**: Players/companies with negative balances
3. **Supply Violations**: More shares/tokens than should exist
4. **Integer Overflow**: Values exceeding safe integer limits

### Medium Priority
5. **Price Manipulation**: Unrealistic price swings (>200%)
6. **Race Conditions**: Inconsistent state from concurrent operations
7. **Duplicate Purchases**: Same upgrade/item purchased multiple times
8. **Authorization Bypass**: Operations performed without proper permissions

### Low Priority (Still Important)
9. **Empty/Invalid Input**: Edge cases with unusual input
10. **Timestamp Issues**: Future dates or very old dates
11. **Precision Loss**: Floating point rounding errors
12. **Performance**: Tests taking unusually long

## Adding New Tests

When adding new game mechanics, create corresponding exploit tests:

```typescript
test("EXPLOIT: [Description of exploit]", async () => {
  const t = convexTest(schema);
  
  // 1. Setup test data
  const playerId = await t.run(async (ctx) => {
    // Create test entities
  });
  
  // 2. Attempt the exploit
  try {
    await t.mutation(api.someEndpoint, {
      // Exploit parameters
    });
    
    // 3. Verify if exploit worked
    const result = await t.run(async (ctx) => {
      // Check for vulnerability
    });
    
    if (/* exploit succeeded */) {
      console.error("⚠️  EXPLOIT DETECTED: Description");
      expect.fail("Exploit description");
    }
  } catch (error) {
    // Expected to fail - exploit prevented
    expect(error.message).toContain("expected error");
  }
});
```

## Test Patterns

### Pattern 1: Direct Value Testing
Test if invalid values are accepted:
```typescript
try {
  await t.mutation(api.endpoint, { amount: -1000 });
  expect.fail("Should not allow negative");
} catch (error) {
  expect(error.message).toContain("positive");
}
```

### Pattern 2: State Consistency Testing
Verify total value conservation:
```typescript
const initialTotal = balance1 + balance2;
// Perform operations
const finalTotal = newBalance1 + newBalance2;
expect(finalTotal).toBe(initialTotal);
```

### Pattern 3: Boundary Testing
Test edge cases:
```typescript
const maxValue = Number.MAX_SAFE_INTEGER;
// Test with maxValue
// Test with maxValue + 1
// Test with 0
// Test with negative
```

### Pattern 4: Race Condition Testing
Concurrent operations:
```typescript
await Promise.all([
  operation1(),
  operation2(),
  operation3(),
]);
// Verify consistency
```

## Integration with CI/CD

Add to your GitHub Actions workflow:

```yaml
name: Exploit Detection Tests
on: [push, pull_request]
jobs:
  exploit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: npm install
      - name: Run exploit detection tests
        run: npm test exploit
      - name: Fail on warnings
        run: |
          if grep -q "⚠️  EXPLOIT DETECTED" test-output.log; then
            exit 1
          fi
```

## Security Best Practices

Based on these tests, implement:

1. **Input Validation**
   - Validate all amounts > 0
   - Check for safe integer bounds
   - Sanitize string inputs

2. **Authorization Checks**
   - Verify ownership before operations
   - Validate user permissions
   - Check entity existence

3. **Atomic Transactions**
   - Use database transactions
   - Rollback on errors
   - Lock resources during updates

4. **Rate Limiting**
   - Limit API calls per user
   - Throttle expensive operations
   - Prevent rapid trading

5. **Logging & Monitoring**
   - Log all high-value transactions
   - Track unusual patterns
   - Alert on suspicious activity

6. **Calculations**
   - Use integers for money (cents)
   - Check for overflow before operations
   - Validate results are finite

7. **Supply Management**
   - Track total supply
   - Validate against supply limits
   - Prevent over-issuance

## Maintenance

### Weekly
- Run full exploit test suite
- Review any new warnings
- Update tests for new features

### Monthly
- Review production logs for patterns matching exploits
- Analyze failed login attempts or rate limit hits
- Update test scenarios based on actual attacks

### Quarterly
- Security audit of all game mechanics
- Penetration testing
- Update documentation

## FAQ

**Q: Why are some tests marked "Manual verification needed"?**
A: These tests require authentication mocking which isn't set up. Test these manually or add auth mocking.

**Q: Should all warnings be treated as failures?**
A: Not always. Review each warning's context. Some warnings indicate design trade-offs rather than exploits.

**Q: How do I know which exploits are most critical?**
A: Focus on tests that show money creation, negative balances, or supply violations first.

**Q: Can I skip these tests in development?**
A: Never skip before merging to main. Run frequently in development to catch issues early.

**Q: What if a test fails after a feature change?**
A: This is expected. Update the test to match the new behavior, but ensure the new behavior is secure.

## Contributing

When adding new game mechanics:
1. Write exploit tests first (TDD approach)
2. Ensure all tests pass before merging
3. Document any intentional design decisions that may look like exploits
4. Update this README with new test categories

## Contact

For security concerns or discovered exploits not covered by these tests, report immediately to the development team.

---

**Last Updated**: 2025-10-27
**Test Coverage**: 66 exploit scenarios across 10 categories
**Status**: Active Development 🔒
