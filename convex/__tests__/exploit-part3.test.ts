/**
 * EXPLOIT DETECTION TEST SUITE - PART 3
 * 
 * Continuation covering:
 * - Gambling exploits
 * - Upgrade exploits
 * - Transaction & transfer exploits
 * - Timing & tick exploits
 */

import { describe, test, expect } from "vitest";
import { convexTest } from "convex-test";
import { api } from "../_generated/api";
import schema from "../schema";

// ============================================================================
// SECTION 7: GAMBLING EXPLOITS
// ============================================================================

describe("Gambling Exploits", () => {
  
  test("EXPLOIT: Gambling with more money than owned", async () => {
    const t = convexTest(schema);
    
    await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-gambler",
      });
      
      await ctx.db.insert("players", {
        userId,
        balance: 1000, // Only $10
        netWorth: 1000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Mock authentication for gambling functions
    // Try to bet more than balance
    // Note: This would require proper auth mocking in real test
    
    console.log("⚠️  Manual verification needed: Test gambling with insufficient balance");
  });
  
  test("EXPLOIT: Rapid gambling to exploit RNG", async () => {
    const t = convexTest(schema);
    
    await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-rng-exploit",
      });
      
      const playerId = await ctx.db.insert("players", {
        userId,
        balance: 100000000, // $1M
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
      
      // Track results to detect pattern
      const results: number[] = [];
      
      // Simulate multiple gambling attempts
      for (let i = 0; i < 100; i++) {
        const roll1 = Math.floor(Math.random() * 6) + 1;
        const roll2 = Math.floor(Math.random() * 6) + 1;
        results.push(roll1 + roll2);
      }
      
      // Check for suspicious patterns
      const avg = results.reduce((a, b) => a + b, 0) / results.length;
      const variance = results.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / results.length;
      
      // Expected average for 2d6 is 7
      if (Math.abs(avg - 7) > 1.5) {
        console.warn(`⚠️  WARNING: RNG may be biased. Average: ${avg.toFixed(2)}, Expected: 7`);
      }
      
      // Check for repeated patterns
      const consecutive = results.slice(0, -1).filter((val, idx) => val === results[idx + 1]).length;
      if (consecutive > 30) {
        console.warn(`⚠️  WARNING: Suspicious consecutive identical results: ${consecutive}/99`);
      }
    });
  });
  
  test("EXPLOIT: Blackjack double-down without sufficient funds", async () => {
    const t = convexTest(schema);
    
    await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-blackjack",
      });
      
      await ctx.db.insert("players", {
        userId,
        balance: 1000, // Only enough for initial bet
        netWorth: 1000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Would test double-down with insufficient funds
    // Requires auth mocking
    console.log("⚠️  Manual verification needed: Test blackjack double-down exploit");
  });
  
  test("EXPLOIT: Negative gambling bets", async () => {
    const t = convexTest(schema);
    
    await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-negative-bet",
      });
      
      await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Test covered in earlier section but worth noting
    console.log("✓ Negative bet protection should be in place");
  });
  
  test("EXPLOIT: Gambling history manipulation", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-history",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Manually insert gambling history with impossible results
    await t.run(async (ctx) => {
      await ctx.db.insert("gamblingHistory", {
        playerId,
        gameType: "slots",
        betAmount: 1000,
        payout: 1000000000, // Unrealistic payout
        result: "win",
        details: {},
        timestamp: Date.now(),
      });
    });
    
    // Check if system validates gambling history
    const history = await t.run(async (ctx) => {
      return await ctx.db
        .query("gamblingHistory")
        .withIndex("by_playerId", (q) => q.eq("playerId", playerId))
        .collect();
    });
    
    const suspiciousWins = history.filter(h => h.payout > h.betAmount * 1000);
    if (suspiciousWins.length > 0) {
      console.warn("⚠️  WARNING: Suspicious gambling payouts detected");
    }
  });
});

// ============================================================================
// SECTION 8: UPGRADE EXPLOITS
// ============================================================================

describe("Upgrade Exploits", () => {
  
  test("EXPLOIT: Purchasing upgrade without sufficient funds", async () => {
    const t = convexTest(schema);
    
    await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-upgrade-poor",
      });
      
      await ctx.db.insert("players", {
        userId,
        balance: 1000, // Too little for upgrades
        netWorth: 1000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Would test purchasing expensive upgrade
    console.log("⚠️  Manual verification needed: Test upgrade purchase with insufficient funds");
  });
  
  test("EXPLOIT: Purchasing same upgrade multiple times", async () => {
    const t = convexTest(schema);
    
    await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-duplicate-upgrade",
      });
      
      await ctx.db.insert("players", {
        userId,
        balance: 1000000000, // $10M
        netWorth: 1000000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    console.log("⚠️  Manual verification needed: Test duplicate upgrade purchase");
  });
  
  test("EXPLOIT: Upgrade multiplier stacking", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-multiplier",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 1000000000,
        netWorth: 1000000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Manually insert multiple same upgrades
    await t.run(async (ctx) => {
      for (let i = 0; i < 5; i++) {
        await ctx.db.insert("upgrades", {
          playerId,
          upgradeType: "stock_returns_boost",
          name: "+50% Stock Returns",
          description: "Boost your stock portfolio returns by 50%",
          cost: 100000000,
          benefit: "+50% Stock Returns",
          isActive: true,
          purchasedAt: Date.now(),
        });
      }
    });
    
    // Check if multipliers stack inappropriately
    const upgrades = await t.run(async (ctx) => {
      return await ctx.db
        .query("upgrades")
        .withIndex("by_playerId", (q) => q.eq("playerId", playerId))
        .filter((q) => q.eq(q.field("isActive"), true))
        .collect();
    });
    
    const stockBoosts = upgrades.filter(u => u.upgradeType === "stock_returns_boost");
    if (stockBoosts.length > 1) {
      console.warn(`⚠️  EXPLOIT DETECTED: Multiple instances of same upgrade: ${stockBoosts.length}`);
    }
  });
  
  test("EXPLOIT: Toggling upgrades to bypass restrictions", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-toggle",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 1000000000,
        netWorth: 1000000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const upgradeId = await t.run(async (ctx) => {
      return await ctx.db.insert("upgrades", {
        playerId,
        upgradeType: "production_cost_reduction",
        name: "-20% Production Costs",
        description: "Reduce production costs for all your company products by 20%",
        cost: 75000000,
        benefit: "-20% Production Costs",
        isActive: true,
        purchasedAt: Date.now(),
      });
    });
    
    // Rapidly toggle upgrade
    for (let i = 0; i < 10; i++) {
      const upgrade = await t.run(async (ctx) => {
        return await ctx.db.get(upgradeId);
      });
      
      if (upgrade) {
        await t.run(async (ctx) => {
          await ctx.db.patch(upgradeId, {
            isActive: !upgrade.isActive,
          });
        });
      }
    }
    
    // Verify no side effects from rapid toggling
    const finalUpgrade = await t.run(async (ctx) => {
      return await ctx.db.get(upgradeId);
    });
    
    expect(finalUpgrade).toBeDefined();
  });
});

// ============================================================================
// SECTION 9: TRANSACTION & TRANSFER EXPLOITS
// ============================================================================

describe("Transaction & Transfer Exploits", () => {
  
  test("EXPLOIT: Creating transactions with invalid account types", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-transaction",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to create transaction with mismatched account types
    try {
      await t.run(async (ctx) => {
        await ctx.db.insert("transactions", {
          fromAccountId: playerId,
          fromAccountType: "company", // Wrong type for player ID
          toAccountId: playerId,
          toAccountType: "player",
          amount: 1000,
          assetType: "cash",
          description: "Test",
          createdAt: Date.now(),
        });
      });
      
      console.warn("⚠️  WARNING: Transaction created with mismatched account type");
    } catch (error) {
      // Expected to fail
    }
  });
  
  test("EXPLOIT: Transaction duplication through race condition", async () => {
    const t = convexTest(schema);
    
    const player1Id = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-player1",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const player2Id = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-player2",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const initialBalance1 = 10000000;
    const initialBalance2 = 10000000;
    
    // Simulate simultaneous transfers
    await Promise.all([
      t.run(async (ctx) => {
        const p1 = await ctx.db.get(player1Id);
        const p2 = await ctx.db.get(player2Id);
        if (p1 && p2) {
          await ctx.db.patch(player1Id, { balance: p1.balance - 1000000 });
          await ctx.db.patch(player2Id, { balance: p2.balance + 1000000 });
        }
      }),
      t.run(async (ctx) => {
        const p1 = await ctx.db.get(player1Id);
        const p2 = await ctx.db.get(player2Id);
        if (p1 && p2) {
          await ctx.db.patch(player2Id, { balance: p2.balance - 500000 });
          await ctx.db.patch(player1Id, { balance: p1.balance + 500000 });
        }
      }),
    ]);
    
    // Check if money was created or lost
    const final1 = await t.run(async (ctx) => {
      return await ctx.db.get(player1Id);
    });
    const final2 = await t.run(async (ctx) => {
      return await ctx.db.get(player2Id);
    });
    
    const totalInitial = initialBalance1 + initialBalance2;
    const totalFinal = (final1?.balance || 0) + (final2?.balance || 0);
    
    if (Math.abs(totalFinal - totalInitial) > 100) {
      console.error(`⚠️  EXPLOIT DETECTED: Money creation/destruction. Initial: ${totalInitial}, Final: ${totalFinal}`);
      expect.fail("Transaction integrity violated");
    }
  });
  
  test("EXPLOIT: Negative transfer amounts", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-negative-transfer",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Transfer Test Co",
        balance: 10000000,
        isPublic: false,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to create transaction with negative amount
    try {
      await t.run(async (ctx) => {
        await ctx.db.insert("transactions", {
          fromAccountId: playerId,
          fromAccountType: "player",
          toAccountId: companyId,
          toAccountType: "company",
          amount: -1000000, // Negative amount
          assetType: "cash",
          description: "Negative transfer",
          createdAt: Date.now(),
        });
      });
      
      console.warn("⚠️  WARNING: Negative transaction amount accepted");
    } catch (error) {
      // Expected to fail
    }
  });
  
  test("EXPLOIT: Self-transfer to duplicate money", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-self-transfer",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const initialBalance = 10000000;
    
    // Try self-transfer
    await t.run(async (ctx) => {
      const player = await ctx.db.get(playerId);
      if (player) {
        // Deduct from player
        await ctx.db.patch(playerId, {
          balance: player.balance - 1000000,
        });
        
        // Add to same player (should be a no-op or handled specially)
        const updatedPlayer = await ctx.db.get(playerId);
        if (updatedPlayer) {
          await ctx.db.patch(playerId, {
            balance: updatedPlayer.balance + 1000000,
          });
        }
      }
    });
    
    const finalPlayer = await t.run(async (ctx) => {
      return await ctx.db.get(playerId);
    });
    
    // Self-transfer should not create money
    expect(finalPlayer?.balance).toBe(initialBalance);
  });
  
  test("EXPLOIT: Transfer larger than balance", async () => {
    const t = convexTest(schema);
    
    const player1Id = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-overdraft1",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 1000, // Small balance
        netWorth: 1000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const player2Id = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-overdraft2",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 1000000,
        netWorth: 1000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Try to transfer more than balance (without proper checks)
    await t.run(async (ctx) => {
      const p1 = await ctx.db.get(player1Id);
      if (p1 && p1.balance >= 1000000) {
        // This should fail - balance check
        await ctx.db.patch(player1Id, {
          balance: p1.balance - 1000000,
        });
        
        const p2 = await ctx.db.get(player2Id);
        if (p2) {
          await ctx.db.patch(player2Id, {
            balance: p2.balance + 1000000,
          });
        }
      }
    });
    
    const finalPlayer1 = await t.run(async (ctx) => {
      return await ctx.db.get(player1Id);
    });
    
    if (finalPlayer1 && finalPlayer1.balance < 0) {
      console.error("⚠️  EXPLOIT DETECTED: Negative balance allowed");
      expect.fail("Overdraft exploit");
    }
  });
});

// ============================================================================
// SECTION 10: TIMING & TICK EXPLOITS
// ============================================================================

describe("Timing & Tick Exploits", () => {
  
  test("EXPLOIT: Manipulating timestamps for advantage", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-timestamp",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now() - 1000000000, // Very old
        updatedAt: Date.now(),
      });
    });
    
    // Create loan with future timestamp
    try {
      await t.run(async (ctx) => {
        await ctx.db.insert("loans", {
          playerId,
          amount: 1000000,
          interestRate: 5,
          remainingBalance: 1000000,
          accruedInterest: 0,
          createdAt: Date.now() + 1000000000, // Future
          lastInterestApplied: Date.now() + 1000000000,
          status: "active",
        });
      });
      
      console.warn("⚠️  WARNING: Future timestamp accepted");
    } catch (error) {
      // May be blocked
    }
  });
  
  test("EXPLOIT: Front-running tick-based price changes", async () => {
    const t = convexTest(schema);
    
    const playerId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-frontrun",
      });
      
      return await ctx.db.insert("players", {
        userId,
        balance: 100000000,
        netWorth: 100000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const companyId = await t.run(async (ctx) => {
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "Frontrun Co",
        ticker: "FRUN",
        balance: 10000000,
        isPublic: true,
        marketCap: 50000000,
        sharesOutstanding: 10000,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const stockId = await t.run(async (ctx) => {
      return await ctx.db.insert("stocks", {
        companyId,
        ticker: "FRUN",
        price: 5000,
        totalShares: 10000,
        marketCap: 50000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Record time of purchase
    const purchaseTime = Date.now();
    
    await t.mutation(api.stocks.buyStock, {
      userId: playerId,
      stockId,
      shares: 100,
      accountType: "player",
      accountId: playerId,
    });
    
    // Immediately trigger tick
    try {
      await t.mutation(api.tick.manualTick);
    } catch (error) {
      // May not be accessible or may fail
    }
    
    // Check if price changed immediately after purchase
    const updatedStock = await t.run(async (ctx) => {
      return await ctx.db.get(stockId);
    });
    
    const timeDiff = Date.now() - purchaseTime;
    if (timeDiff < 1000 && updatedStock && updatedStock.price !== 5000) {
      console.log("ℹ️  Note: Price changed immediately after purchase (may be by design)");
    }
  });
  
  test("EXPLOIT: Triggering multiple ticks simultaneously", async () => {
    const t = convexTest(schema);
    
    // Record initial tick count
    const initialTicks = await t.run(async (ctx) => {
      return await ctx.db.query("tickHistory").collect();
    });
    
    // Try to trigger multiple ticks at once
    const tickPromises = [
      t.mutation(api.tick.manualTick).catch(() => null),
      t.mutation(api.tick.manualTick).catch(() => null),
      t.mutation(api.tick.manualTick).catch(() => null),
    ];
    
    await Promise.all(tickPromises);
    
    const finalTicks = await t.run(async (ctx) => {
      return await ctx.db.query("tickHistory").collect();
    });
    
    const ticksAdded = finalTicks.length - initialTicks.length;
    
    if (ticksAdded > 1) {
      console.warn(`⚠️  WARNING: Multiple ticks executed simultaneously: ${ticksAdded}`);
    }
  });
  
  test("EXPLOIT: Tick budget manipulation", async () => {
    const t = convexTest(schema);
    
    // Try to modify bot budget
    try {
      await t.mutation(api.gameConfig.updateConfig, {
        key: "botBudget",
        value: 999999999999, // Massive budget
      });
      
      const newBudget = await t.query(api.gameConfig.getConfig, {
        key: "botBudget",
      });
      
      if (newBudget > 100000000) { // More than $1M
        console.warn(`⚠️  WARNING: Bot budget set to unrealistic value: ${newBudget}`);
      }
    } catch (error) {
      // May be admin-only
    }
  });
  
  test("EXPLOIT: Stock price history manipulation", async () => {
    const t = convexTest(schema);
    
    const companyId = await t.run(async (ctx) => {
      const userId = await ctx.db.insert("users", {
        tokenIdentifier: "test-history-manip",
      });
      
      const playerId = await ctx.db.insert("players", {
        userId,
        balance: 10000000,
        netWorth: 10000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
      
      return await ctx.db.insert("companies", {
        ownerId: playerId,
        name: "History Co",
        ticker: "HIST",
        balance: 10000000,
        isPublic: true,
        marketCap: 50000000,
        sharesOutstanding: 10000,
        reputationScore: 0.5,
        flaggedStatus: false,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    const stockId = await t.run(async (ctx) => {
      return await ctx.db.insert("stocks", {
        companyId,
        ticker: "HIST",
        price: 5000,
        totalShares: 10000,
        marketCap: 50000000,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    });
    
    // Insert fake historical prices
    await t.run(async (ctx) => {
      await ctx.db.insert("stockPriceHistory", {
        stockId,
        price: 1000000, // Unrealistic price
        timestamp: Date.now() - 1000000,
      });
    });
    
    // Check if history validation exists
    const history = await t.query(api.stocks.getStockPriceHistory, {
      stockId,
      timeframe: "ALL",
    });
    
    const suspiciousPrices = history.filter(h => h.price > 1000000 || h.price < 1);
    if (suspiciousPrices.length > 0) {
      console.warn(`⚠️  WARNING: Suspicious price history entries: ${suspiciousPrices.length}`);
    }
  });
});

// ============================================================================
// SUMMARY
// ============================================================================

describe("Exploit Detection Summary", () => {
  test("Generate exploit detection report", () => {
    console.log("\n" + "=".repeat(70));
    console.log("EXPLOIT DETECTION TEST SUITE - SUMMARY");
    console.log("=".repeat(70));
    console.log("\nThis test suite checks for exploits in the following areas:");
    console.log("\n1. Balance & Currency Exploits");
    console.log("   - Negative balance creation");
    console.log("   - Integer overflow/underflow");
    console.log("   - Zero-cost transactions");
    console.log("   - Race conditions on balance deduction");
    console.log("\n2. Stock Market Exploits");
    console.log("   - Price manipulation through rapid trading");
    console.log("   - Share supply violations");
    console.log("   - Invalid price states (NaN, Infinity)");
    console.log("   - Insufficient company funds for buyback");
    console.log("\n3. Cryptocurrency Exploits");
    console.log("   - Duplicate tickers");
    console.log("   - Supply violations");
    console.log("   - Price manipulation");
    console.log("\n4. Loan Exploits");
    console.log("   - Multiple loans bypassing limits");
    console.log("   - Negative repayments");
    console.log("   - Interest overflow");
    console.log("   - Double repayment");
    console.log("\n5. Company & Product Exploits");
    console.log("   - IPO violations");
    console.log("   - Production cost manipulation");
    console.log("   - Stock/inventory manipulation");
    console.log("   - Duplicate tickers");
    console.log("\n6. Marketplace & Cart Exploits");
    console.log("   - Max order violations");
    console.log("   - Stock availability bypass");
    console.log("   - Price change exploits");
    console.log("   - Cart total manipulation");
    console.log("\n7. Gambling Exploits");
    console.log("   - Insufficient balance betting");
    console.log("   - RNG exploitation");
    console.log("   - History manipulation");
    console.log("\n8. Upgrade Exploits");
    console.log("   - Duplicate purchases");
    console.log("   - Multiplier stacking");
    console.log("\n9. Transaction & Transfer Exploits");
    console.log("   - Invalid account types");
    console.log("   - Race condition duplication");
    console.log("   - Negative transfers");
    console.log("   - Self-transfer money creation");
    console.log("   - Overdraft exploits");
    console.log("\n10. Timing & Tick Exploits");
    console.log("   - Timestamp manipulation");
    console.log("   - Front-running");
    console.log("   - Multiple simultaneous ticks");
    console.log("   - Budget manipulation");
    console.log("   - History manipulation");
    console.log("\n" + "=".repeat(70));
    console.log("Run these tests regularly to ensure game integrity!");
    console.log("=".repeat(70) + "\n");
  });
});
